
 REAM MODE PROGRAMMING
 ==============================

 This directory and its contents are part of SYSeg.
 Copyright (c) 2021 - Monaco F. J. <monaco@usp.br>
 SYSeg is Free Software distributed under GNU GPL vr3.
 Further information see http://gitlab.com/monaco/syseg

  Overview
 ------------------------------

 This directory contains a series of examplis comprising a step-by step
 bare-metal implementation of a traditional Hello World program,
 indented to book and execute in a conventional x86 platform.

 The sequence starts with as simple as a source code written directly
 in machine code, wich is then rewriten in assembly and incrementally
 improved until we transform it in a familiar C source code.

 Source code examples include explanatory inline comments and are
 accompanied with corresponding technical discussions laid in this
 file, which one should be able to go through in the suggested order.
 For convenience, a build script (Makefile) is provided which contain
 rules to build, test, inspect and disassembly the content files.
 It may be useful to refer to this script to understand how the
 build tools (compiler, assembler, linker) are used.

 Directions
 ------------------------------

 In order to experiment with the examples in this section, the following
 pieces of software are required. The version indication lists those with
 which the project was tested. Using a more recent version should be
 ok, but it is not absolutely guaranteed that results may exhibit minor
 variations. Feedback is always appreciated.

 - GCC 	     	 9.3.0
 - binutils 	 2.34
 - nasm		 2.14.02
 - qemu		 4.2.1		(qemu-system-i386)
 - gcc-multilib  9.3.0		(to compile 32-bit code in a 64-bit platform)

 If you may also need

 - xorriso	1.5.2-1		(depending on your computer's BIOS)



 
 BUILD INSTRUCTIONS
 

 Use

   make foo				     Build foo.

   make run IMG=foo	             	     Test foo with the emulator.

   make diss IMG=foo 			     Disassemble foo.

   	     	     			     Optionally,

					        ASM  = intel | att  (default)
						BIT  =    16 | 32   (default)

   make dump IMG=foo			     Show the raw contents of foo.
   
   make      			             build everything (or make all)

   make clean			             undo make all

   make stick IMG=foo STICK=/dev/sdX         make a bootable USB stick

   make iso IMG=foo	             	     build an iso9660 image with foo

   make diff foo bar baz		     Show graphical diff between files

   	     	     			     ASM and BIT variables apply

   SHORTCUTS

   make foo/diss			     disassembly as 32-bit AT&T
   make foo/diss intel|att		     disassembly as 32-bit Intel or AT&T
   make foo/diss 16|32			     disassembly as 16-bit or 32-bit
   make foo/diss intel\att 16|32	     disassembly as Intel|AT&T 16|32 bit
   make foo/diss 16|32 intel|att	     disassembly as Intel|AT&T 16|32 bit

   make foo/i16	       			     disassembly as Intel 16-bit
   make foo/i32	       			     disassembly as Intel 32-bit
   make foo/a16 or foo/16 		     disassembly as AT&T  16-bit
   make foo/a32	of foo/32       	     disassembly as AT&T  32-bit

   make foo/dump			     show raw contents in hexadecimal

   make foo/run				     test foo with the emulator
 
 

 Some examples allow alternative build recipes which can be selected
 by passing the command-line variable ALT=<number> to 'make'. See bellow. 

 File names:

     eg-00.ext		contain the main examples;
     egx-00.ext		contain auxiliary extra examples.

 File extensions:

     hex		ASCII file containing values
     			in hexadecimal representation;

     asm		manually written assembly code in
     			Intel ASM format;

     S			manually written assembly code
     			in AT&T Gas format;

     s			assembly code in AT&T Gas format
     			generated by the compiler (GCC);

     o			object code produced by the assembler;

     bin		binary file generated by the
     			compiler /linker;

     ld			linker script.



 NOTE ON BOOTING THE REAL HARDWARE

    Unfortunately, not all BIOSes  handle USB boot devices in the same
    way (welcome to system level). Some are likely to emulate it as a floppy
    disk and rely on the original IBM PC boot method we are exploring here.
    If so, you should be able to prepare your stick using 'make stick'
    with the command line variable IMG=foo.bin. Otherwise, if your computer's
    BIOS emulates your USP stick as a CD-ROM, you should be better served
    by passing it the variable IMG=foo.iso.  See note (1) by the end.


 WORDS OF WISDOM

    If you plan to boot the examples in the physical hardware, check which
    device represents your USB stick. You may use, for instance lsblk utility.
    Your devices should possibly list as /dev/sdX, with X being a, b, c etc.

    If you have only one storage device, say your HD, it may appear as
    /dev/sda, and when you plug your USB stick, it'll take the next
    available letter and appears as /dev/sdb.  You should be required
    administrative privileges (sudo) to write directly into your device.

    Be careful: you're entering system-level. 

    If you misspell your stick as /dev/hda, you may end up grieving in
    pitiful misery and hopeless regrets... do not lower your guard.

 Contents
 ------------------------------


 Take a look at the following examples, preferably in the suggested order.


 * eg-00.S   	    Write a character character on the video display memory

   		    The character is referred to by an immediate value.

 * eg-01_alpha. S   Attempt to write from memory to video display memory

   		    We are gradually taking steps to write a string... but for
		    now, to keep things simple, we're staring with the first
		    character only.

		    We try to address the character as a memory location.
		    
  		    The thing is, this code does not work, though.

		    Take a look at the source and try to spot the problem.

 * eg-01.S	    Like its alpha release, but with the problem fixed.

   		    We use the extra segment register to handle the issue.

  
 * eg-02.c          This is a port of eg-01.S in C.

   		    We inicialize segment registers in rt0.c.

		    Function print() uses inline assembly.

 * eg-03.c	    Like eg-02.c, but with print() written in plain C.

   		    Since what we do is simply write onto memory, we can use
		    the regular C constructs of variable attribution; no
		    assembly need in the function implementation. 



 Notes
 ------------------------------

 (1)   Original PC's BIOS used to read the MBR from the first 512 bytes of
       either the floppy or hard disks. Later on, when CD-ROM technology
       came about, it brought a different specification for the boot
       information, described in the iso9960 (the conventional CD file system
       format). Vendors then updated the BIOSes to detect whether the storage
       is either a floppy (or HD) or a CD-ROM, and apply the appropriate boot
       procedure. More recently, when USB flash devices were introduced, the
       approach adopted by BIOS vendors was not to specify a new boot procedure,
       but to emulate  some of the former devices. The problem is that this
       choice is not very consistent: some BIOSes would detect a USB stick as
       a floppy, whereas other BIOSes would see it as a CD (welcome to the
       system layer!).

       If your BIOS mimics the original PC, to make a bootable USB stick
       all you need to do is to copy the MBR code to its first 512 bytes:


   	  make stick IMG=foo.bin STICK=/dev/sdX


       On the other hand, if your BIOS insists in detecting your USB stick
       as a CD-ROM, you'll need to prepare a bootable iso9660 image as
       described in El-Torito specification [1]. 

       As for that, the GNU xorriso utility may come in handy: it prepares a
       bootable USP stick which should work in both scenarios. Xorriso copies
       the MBR code to the first 512 bytes to the USB stick and, in addition,
       it also transfer a prepared iso9660 to the right location. If you can't
       get your BIOS to boot and execute the example with the above (floppy)
       method, then try

         make stick IMG=foo.iso STICK=/dev/sdX


       We wont cover iso9660 El-Torito boot for CD-ROM, as newer x86-based
       computers now offers the Unified Extensible Firmware Interface meant
       to replace the BIOS interface of the original PC.  EFI is capable
       of decoding a format device, allowing the MBR code to be read from a
       standard file system. Although EFI is gradually turning original PC
       boot obsolete, however, most present day BIOSes offer a so called
       "legacy mode BIOS" and its useful to understand more sophisticated
       technologies, as low-level boot is still often found in legacy
       hardware and embedded systems.


  (2)   Original i8086 architecture did not have 32-bit di (edi) register.       
        The only way to reach b800:0000 begin at %ds=0 would be to load          
        0xb800 into %ds or %es.                                                  

	This is what we do in egx-01.S

        Wen we boot a modern x86 nowadasy, it emulates an i8086 hardware         
        but its still an i386 CPU. A 32-bit %edi register does exists            
        and the emulation allow us to load 32-bit values into it. The            
        segments %ds and %es wtill work, though.                                 
                                                                                 
        It is therefore one may take advantage of this to access memory          
        beyond the scope of the current 64k segment.

	This is what we do in egx-02.S

	You can compare both versions with

	    make diff egx-01.bin egx-02.bin BIT=32

	That said, this is not portable to original i8086 and, arguably,
	in a strict sense not plain 16-bit real-mode programming.            

 References
 ------------------------------
 
 [1] Auxiliary program: syseg/src/hex2bin

 [2] El-Torito: https://wiki.osdev.org/El-Torito
