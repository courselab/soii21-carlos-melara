
 OVERVIEW
 ------------------------------

 In order to experiment with the examples in this section, the following
 pieces of software are required. The version indication lists those with
 which the project was tested. Using a more recent version should be
 ok, but it is not absolutely guaranteed that results may exhibit minor
 variations. Feedback is always appreciated.

 - GCC 	     	 9.3.0
 - binutils 	 2.34
 - nasm		 2.14.02
 - qemu		 4.2.1		(qemu-system-i386)


 BUILD DIRECTIONS
 ------------------------------

 Use

   make name.bin		to build name.bin out of name.ext

   make run IMG=name.bin	to test name.bin with the emulator

   make diss IMG=name.bin	to disassemble name.bin

   make dump IMG=name.ext	to dump the raw contents of name.ext

   make      			to build everything (or make all)

   make clean			to undo make all

   make help			usage information


 Some examples allow alternative build recipes which can be selected
 by passing the command-line variable ALT=<number> to make. See bellow. 

 Files

     eg-00.ext		contain the main examples;
     egx-00.ext		contain auxiliary extra examples.

 Extension

     hex		indicates an ASCII file containing values
     			in hexadecimal representation;

     asm		indicates manually written assembly code in
     			Intel ASM format;

     S			indicates manually written assembly code
     			in AT&T Gas format;

     s			indicates assembly code in AT&T Gas format
     			generated by the compiler (GCC);

     o			indicates object code produced by the assembler;

     bin		indicates binary file generated by the
     			compiler /linker;

     ld			script passed to the linker.


 CONTENTS
 ------------------------------

 Take a look at the following examples.
 


 * eg-01.hex	    Bare-metal hardcore Hello World in machine code.
 
   		    This is a tough old-school version of the classical
		    Hello World program. It writes the string directly to the
		    BIOS video memory, character by character, one at a time.
		    A Hello World as you may have never made before, with
		    neither an OS, nor a programming language, not even
		    assembly; just bare machine code.

		    The source code is an ASCII file containing the opcodes of
		    the program in hexadecimal representation.

		    Build with it with a simple hex-to-binary converter. 


 * eg-02.asm	    The same as eg-01.hex, but now in assembly code.

   		    This program implements literally the same algorithm as
		    eg-02.hex, but written in assembly code, Intel syntax.
		    Use nasm assembler to build the binary (see note 1).

		    This is a literal translation of of the machine code
		    into Intel NASM assembly syntax (see note 1).

		    Compare eg-01.bin and eg-02.bin with

		    $ make diss IMG=eg-01.bin
		    $ make diss IMG=eg-02.bin

		    and see that the resulting object codes match.


 * eg-03-beta.asm   A variation of eg-02.asm, using a loop.

  		    Notice that now that we are dealing with offsets, we must
		    beware of the RAM load address.
		    
 * eg-03.asm	    Same as eg-03-beta.asm, but using the 'org' directive.

   		    The directive 'org' causes all labels to be offset
		    to match the position where BIOS loads the program.

   		    Now it's time to bear in mind that asm is performing
		    both the assembling (object code generation) and
		    linking (build-time address relocation) steps.


* eg-04.asm	    A more elegant version of eg-03, just with neater code.

		    Compare eg-03.bin and eg-04.bin with

		    $ make diss IMG=eg-03.bin
		    $ make diss IMG=eg-04.bin
  		    
		    and see that the resulting object codes match.

* eg-05-beta.1.S    Like eg-05.asm, but translated into AT&T assembly syntax.

   		    The translation was made as literal as possible so as to
		    facilitate the comparison. One motivation for using AT&T
		    syntax is to allow for the utilization of GNU development
		    toolset (e.g. GCC) and explore its sophisticated
		    capabilites --- which should come in handy to port the
		    source code of the running to C language, with the aid of
		    inline assembly and other useful features.
		    
		    One could well ask why we can't just use GCC to convert
		    from C to assembly, and then just use NSAM to perform
		    assembling and linking as before? Well, it is because the
		    assembly generated by GCC from C does not goes well with
		    NASM. See note 2 bellow for further detailing.

		    Compare eg-03.bin, eg-05.bin and eg-05.bin with

		    A noteworthy observation is that the build procedure of
		    this example involves two steps: assembling and linking.
		    With NASM, which we had been using previously, those
		    two steps were performed by the same program. In the GNU
		    development toolchain they are performed by distinct
		    program. The GAS assembler (as) convert assembly to
		    object code (machine code), and then the linker is used
		    to remap the addresses offset to match the RAM load
		    address (we pass it as command line argument to the linker
		    rather than via an inline directive).


* eg-05-beta.2.S   Same as before, but using global symbol for entry point.

   		    This example is just to illustrate that the linker can
		    recognize the entry point as a label, rather than through
		    the absolute offset.

 * eg-05.S	    Same as before, but with standard entry point name.

   		    This example is to illustrate that the default symbol name
		    for the entry point is __start. If we stick to it, we do
		    not need to pass it as an option for to the linker. Later
		    on, we'll see that the assembly generated by C compiler
		    has an entry point with that name.

		    Alternative:

		    Issuing the build rule with the command-line variable
		    ALT=1 selects an alternative recipe using a single GCC 
		    invocation (GCC then invokes assembler and linker with
		    appropriate arguments).


		    $ make diss IMG=eg-03.bin
		    $ make diss IMG=eg-04.bin
		    $ make diss IMG=eg-05.bin

		    and see that they all match.


* eg-06.S	    Program eg-06.S modified to manipulate 32-bit registers.

    		    Why that? The main reason is that we want to use GCC
		    to produce 16-bit assembly, which we can further
		    process with GAS. However, GCC does not do a good job
		    producing 16-bit assembly code. It works very well for
		    32-bit and 64-bit but not with 16-bit. To better
		    understand it, see note 3 ahead.

		    Alternative:

		    Issuing the build rule with the command-line variable
		    ALT=1 selects an alternative recipe using a single GCC 
		    invocation (GCC then invokes assembler and linker with
		    appropriate arguments).

* eg-07.c	    Like eg-07.S, but translated into C.

   		    We use basic inline assembly.

		    Alternatives:

		    b) Issuing the build rule with the command-line variable
		    ALT=1 selects an alternative recipe using a linker
		    script which stands in for some of the compiler's and
		    linker's flags, in particular, the instructions to
		    generate flat binary, set entry point and copy only
		    the code (.text) section to the output.

		    a) Issuing the build rule with the command-line variable
		    ALT=1 selects an alternative recipe using a single line
		    compiler (gcc) invocation.

 * eg-08.c	    Like eg-07.S, but adding the signature via linker script.




 Notes
 ------------------------------

 (1) As a side note, we do not refer to assembly as a programming language
     in the same way refer to the C language. First, the assembly mnemonics
     depend on the opcodes of target processor e.g. i386, ARM etc. ---
     not to mention 16, 32, 64-bit registers etc. Second, even with respect
     to one processor, there are different syntaxes such as Intel and AT&T.
     And, even more, different assemblers (piece of software which generates
     machine code from the assembly code) implement their own dialects. For
     instance, GNU assembler (gas) can read Intel assembly syntax, but in
     a different dialect (minor syntax incongruences) than that used by
     NASM assembler.


 (2)  One reason we had better switch from nasm (Intel) to gas (AT&T)
      assembly here is because GCC (compiler) and NASM (assembler) do
      not go that well together. Whereas GCC outputs AT&T syntax by default,
      it does is capable of outputing Intel assembly if asked by means
      of 'masm' option.  The problem is that the latter comes in a
      specific Intel assembly dialect meant for GAS (GCC toolchain),
      which is not the same as that understood by NASM. And NASM does not
      understand GCC's AT&T assembly either.  Because of this, we can not
      take the assembly produced by GCC and feed it into nasm. Thus, if
      we intend to write in C and compile with GCC, we are compelled
      to use GAS --- and thereby AT&T assembly.  The alternative to
      keep NASM would be to change the C compiler (indeed, I have tried
      without success to use TCC and BCC, but at the end of the day,
      GNU development toolset turned a lot more appealing for the
      present purpose).

      Indeed, there is another reason NASM do not work well with GCC's inline
      assembly, and this has to do with the reasons laid in note 3.
      
 (3)  Put short, GCC does not currently produces 16-bit assembly code.
      Yes, GCC does create 16-bit binaries but to that end, it produces
      an assembly which used 32-bit registers, and rely on GAS to 
      fix the assembly into a 16-bit binary. For instance, if the C code
      should translate into a 16-bit machine code equivalent to

         mov ax, 0x1

      GCC, event with the option -m16, may well output

         mov eax, 0x01

     and leave a directive (.code16gcc) in the assembly file. In the
     subsequent step, GAS will find this directive and honor it by
     producing a 16-bit machine code.

     One may verify this by building the auxiliary extra examples

     	 make egx-01-16.o
	 make egx-01.32.o

     and inspecting the produced assembly codes

     	 diff -y --color egx-01-16.s egx-01.32.s

     Both should differ only in the line corresponding to the assembler
     directive for 16-bit code.

     On the other hand, the dissembling of the objects

     	 diff --color <(make diss IMG=egx-01-16.o) \
	              <(make diss IMG=egx-01-32.o)

     shows that 16-bit or 32-bin registers are indeed used. 

     The reason why GCC does not output 16-bit assembly has to do with
     design decisions and priorities of the project. 


 References
 ------------------------------
 
 [1] Auxiliary program: syseg/src/hex2bin
