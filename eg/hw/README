
			BARE-METAL HELLO WORLD


 Overview
 ------------------------------

 This directory contains a series of examplis comprising a step-by step
 bare-metal implementation of a traditional Hello World program,
 indented to book and execute in a conventional x86 platform.

 The sequence starts with as simple as a source code written directly
 in machine code, wich is then rewriten in assembly and incrementally
 improved until we transform it in a familiar C source code.

 Source code examples include explanatory inline comments and are
 accompanied with corresponding technical discussions laid in this
 file, which one should be able to go through in the suggested order.
 For convenience, a build script (Makefile) is provided which contain
 rules to build, test, inspect and disassembly the content files.
 It may be useful to refer to this script to understand how the
 build tools (compiler, assembler, linker) are used.

 Directions
 ------------------------------

 In order to experiment with the examples in this section, the following
 pieces of software are required. The version indication lists those with
 which the project was tested. Using a more recent version should be
 ok, but it is not absolutely guaranteed that results may exhibit minor
 variations. Feedback is always appreciated.

 - GCC 	     	 9.3.0
 - binutils 	 2.34
 - nasm		 2.14.02
 - qemu		 4.2.1		(qemu-system-i386)
 - gcc-multilib  9.3.0		(to compile 32-bit code in a 64-bit platform)

 If you may also need

 - xorriso	1.5.2-1		(depending on your computer's BIOS)


 BUILD INSTRUCTIONS


 Use

   make foo				     Build foo.

   make run IMG=foo	             	     Test foo with the emulator.

   make diss IMG=foo 			     Disassemble foo.

   	     	     			     Optionally,

					        ASM  = intel | att  (default)
						BIT  =    16 | 32   (default)

   make dump IMG=foo			     Show the raw contents of foo.
   
   make      			             build everything (or make all)

   make clean			             undo make all

   make stick IMG=foo STICK=/dev/sdX         make a bootable USB stick

   make iso IMG=foo	             	     build an iso9660 image with foo

   make diff foo bar baz		     Show graphical diff between files

   	     	     			     ASM and BIT variables apply

   SHORTCUTS

   make foo/diss			     disassembly as 32-bit AT&T
   make foo/diss intel|att		     disassembly as 32-bit Intel or AT&T
   make foo/diss 16|32			     disassembly as 16-bit or 32-bit
   make foo/diss intel\att 16|32	     disassembly as Intel|AT&T 16|32 bit
   make foo/diss 16|32 intel|att	     disassembly as Intel|AT&T 16|32 bit

   make foo/i16	       			     disassembly as Intel 16-bit
   make foo/i32	       			     disassembly as Intel 32-bit
   make foo/a16 or foo/16 		     disassembly as AT&T  16-bit
   make foo/a32	of foo/32       	     disassembly as AT&T  32-bit

   make foo/dump			     show raw contents in hexadecimal

   make foo/run				     test foo with the emulator


 Some examples allow alternative build recipes which can be selected
 by passing the command-line variable ALT=<number> to 'make'. See bellow. 

 File names:

     eg-00.ext		contain the main examples;
     egx-00.ext		contain auxiliary extra examples.

 File extensions:

     hex		ASCII file containing values
     			in hexadecimal representation;

     asm		manually written assembly code in
     			Intel ASM format;

     S			manually written assembly code
     			in AT&T Gas format;

     s			assembly code in AT&T Gas format
     			generated by the compiler (GCC);

     o			object code produced by the assembler;

     bin		binary file generated by the
     			compiler /linker;

     ld			linker script.



 NOTE ON BOOTING THE REAL HARDWARE

    Unfortunately, not all BIOSes  handle USB boot devices in the same
    way (welcome to system level). Some are likely to emulate it as a floppy
    disk and rely on the original IBM PC boot method we are exploring here.
    If so, you should be able to prepare your stick using 'make stick'
    with the command line variable IMG=foo.bin. Otherwise, if your computer's
    BIOS emulates your USP stick as a CD-ROM, you should be better served
    by passing it the variable IMG=foo.iso.  See note (1) by the end.


 WORDS OF WISDOM

    If you plan to boot the examples in the physical hardware, check which
    device represents your USB stick. You may use, for instance lsblk utility.
    Your devices should possibly list as /dev/sdX, with X being a, b, c etc.

    If you have only one storage device, say your HD, it may appear as
    /dev/sda, and when you plug your USB stick, it'll take the next
    available letter and appears as /dev/sdb.  You should be required
    administrative privileges (sudo) to write directly into your device.

    Be careful: you're entering system-level. 

    If you misspell your stick as /dev/hda, you may end up grieving in
    pitiful misery and hopeless regrets... do not lower your guard.

    

 Contents
 ------------------------------


 Take a look at the following examples, preferably in the suggested order.
 


 * eg-01.hex	    Bare-metal hardcore Hello World in machine code.
 
   		    This is a tough old-school version of the classical
		    Hello World program. It writes the string directly to the
		    BIOS video memory, character by character, one at a time.
		    A Hello World as you may have never made before, with
		    neither an OS, nor a programming language, not even
		    assembly; just bare machine code.

		    The source code is an ASCII file containing the opcodes of
		    the program in hexadecimal representation.

		    Build with it with a simple hex-to-binary converter. 


 * eg-02.asm	    The same as eg-01.hex, but now in assembly code.

   		    This program implements literally the same algorithm as
		    eg-01.hex, but written in assembly code, using Intel
		    syntax. This is the assembly understood by NASM assembler,
		    used here to build the binary.

		    Compare eg-01.bin and eg-02.bin, by disassembling them with

		      make eg-01.bin/16i
		      make eg-02.bin/16i

                    or, alternatively, with the graphical tool

		      make diff eg-01.bin eg-02.bin BIT=16 ASM=intel

		    and see that the resulting object codes match.

		    We are forcing the disassembler to interpret the object
		    as code for a i8086 (16-bit) CPU, using intel asm syntax.


 * eg-03-beta.asm   A variation of eg-02.asm, using a loop.

  		    Notice that now that we are dealing with offsets, we must
		    beware of the RAM load address.
		    
 * eg-03.asm	    Same as eg-03-beta.asm, but using the 'org' directive.

   		    The directive 'org' causes all labels to be offset
		    to match the position where BIOS loads the program.

   		    Now it's time to bear in mind that asm is performing
		    both the assembling (object code generation) and
		    linking (build-time address relocation) steps.


* eg-04.asm	    A more elegant version of eg-03, just with neater code.

		    Compare eg-03.bin and eg-04.bin with

		      make eg-03.bin/i16 
		      make eg-04.bin/i16 
  		    
		    and see that the resulting object codes match.

* eg-05-beta.1.S    Like eg-05.asm, but translated into AT&T assembly syntax.

  		    One motivation to convert the assembly source code from
		    Intel to AT&T dialect is because we intend to rewrite
		    the running example in C language.  To that end, we will
		    use the powerful and flexible GNU compiler collection.
		    The thing is, GCC's toolchain speaks AT&T asm and does not
		    understand NASM's intel asm.

		    See note (2) for further detailing.

   		    The translation was made as literal as possible so as to
		    facilitate the comparison with eg-04.asm.

		    A noteworthy observation is that the build procedure of
		    this example involves two steps: assembling and linking.
		    The former translates assembly to object (machine) code,
		    and the latter remaps offsets to match the load address.
		    Those are the normal duties of the assembler and the linker.
		    With NASM, which we had been using previously, those
		    two functions are performed by the same program. In the
		    GNU development toolchain, differently, those duties are
		    performed by two distinct programs: the assembler (GAS,
		    whose executable program name is 'as') converts assembly
		    to object code (machine code), and then the linker (ld)
		    is used to remap the addresses offset to match the RAM
		    load address. GAS does not have an equivalent for the
		    .org directive that we used with NASM for this purpose;
		    we inform the linker directly via a command line option.

		    Moreover, whilst we had instructed NASM to produce a flat
		    binary, the version of GAS installed in our x86 / x86_64
		    platform outputs binaries in ELF format --- a structured
		    executable format that has much more than the executable
		    code section (e.g. header, relocation information and
		    other metadata). It is the liker who is responsible to
		    strip all extra sections and output a flat binary.
		    We tell ld to do that using another command-line option.

		    Finally, ld let us specify which will be the entry point
		    of the executable. This would be important for structured
		    file formats such as ELF (Linux) or PE (windows). For
		    us, it's the first byte. However, since ld dos expect it,
		    we pass this information in yet another command-line option.


 * eg-05-beta.2.S   Same as before, but using global symbol for entry point.

   		    This example is just to illustrate that the linker can
		    recognize the entry point as a label, rather than through
		    the absolute offset.

 * eg-05.S	    Same as before, but with standard entry point name.

   		    This example is to illustrate that the default symbol name
		    for the entry point is _start. If we stick to it, we do
		    not need to pass it as an option for to the linker. 

		    Alternative:

		    Issuing the build rule with the command-line variable
		    ALT=1 selects an alternative recipe using a single GCC 
		    invocation (GCC then invokes the assembler and the linker
		    with appropriate arguments).

		    Disassemble with 

		      make eg-03.bin/i16 
		      make eg-04.bin/i16
		      make eg-05.bin/i16 

		    and see that they all binaries match.

 * eg-06.S	    Like eg-05.S, but modified to manipulate 16-bit registers.

   		    Here we implement the same algorithm as in eg-05.S, but
		    with an alternative code to read and write in both 8-bit
		    registers ah and al by means of manipulating the 16-bit
		    register ax, rather than accessing its higher and lower
		    bytes of directly. 

		    The main reason for doing this, despite the need of some
		    gimmick with bitwise logic operation and an extra register,
		    is because we intend to port our source code from assembly
		    to C and use GNU toolchain to build it.

		    See note (3) for a glimpse on how it would look like

		    It so happens that GCC does not do a good job working with
		    8-bit registers. As we are taking steps to convert our
		    assembly example into C, limitation will eventually get in
		    our way when we start to experiment with C inline assembly.

		    See note (4) to better understand the issue.
		    		    
		    In order to overcome the limitation, we'd better modify
		    our code to manipulate only 16-bit registers.		    

		    Build eg-06.bin and inspect it with

		       make diss IMG=eg-06.bin 32

		    Why are we forcing the disassemble to interpret the object
		    as a 32-bit code? Because GAS assumes this code should
		    be interpreted as a i8086 (16-bit) binary intended to run
		    in a i386 (32-bit) machine (see note 3).


* eg-07-beta.c	    Like eg-06.S, but translated into C.

   		    We use basic inline assembly. GCC should copy the asm code
		    as is to the output asm.

		    We declared the function with attribute 'naked' to prevent
		    GCC from generating extra asm code which is not relevant
		    here and may be omitted for readability. See comments
		    in the source file.

		    NOTE: There are some weightly concerns about this technique
		    to be addressed in the following examples.

		    Observe that the string is now allocated in the read-only
		    section of the object code --- and also the ad hoc
		    workaround (aka dirty hack) we used (see comments in
		    the source file).

		    Alternatives:

		    b) Issuing the build rule with the command-line variable
		    ALT=1 selects an alternative recipe using a linker
		    script which stands in for some of the compiler's and
		    linker's flags, in particular, the instructions to
		    generate flat binary, set entry point and copy only
		    the code (.text) section to the output.

		    a) Issuing the build rule with the command-line variable
		    ALT=2 selects an alternative recipe using a single line
		    compiler (gcc) invocation. Note that now we need
		    to use gcc's option -nostdlib.


 * eg-07.c	    Like eg-07-beta.c, but handling .rodata with the ld script


   		    We use a linker script to move .rodata to .text section.
		    Moreover, we user the linker to add the boot signature.

		    Bearing in mind that there is possibly more than one way
		    to implement the behavior specified by the C source code
		    into assembly form, it is not guaranteed that both the
		    handwritten eg-06.s and the GCC-produced eg-07.s codes
		    will match --- let alone the resulting machine codes
		    eg-06.bin and eg-07.bin.

		    One may check it by comparing

		    	make eg-06.bin/diss 16
			make eg-07.bin/diss 16


		    A more similar binary code may be obtained by enabling
		    some optimization
		    
		    	make eg-06.bin/diss 16
			make eg-07-O1.bin/diss 16

                    An alternative implementation which manipulate only 32-bit
		    registers may be seen in egx-06.c.

* eg-08.c	    A complete rewrite of eg-07.c with safer code.

   		    Using register variables and basic C inline assembly as
		    in eg-07.c seems appealing at first glance... but in
		    a dangerous way. The example did work, but only because
		    certain rather restrictive conditions hold.

		    To have an intuitive grasp on the potential problem,
		    refer to note (5).

		    The example, although (hopefully) working, is error prone
		    and generally not a good idea.

		    This is rewrite of eg-07.c using simple asm encapsulated
		    as function-like macros.

		    The macro usage has some limitations which are overcome
		    in the examples which follow.

 * eg-09.c	    A rewrite of 08.c replacing macros with functions.

   		    The limitations of eg-08.c's macro usage are overcome, yet with
		    simple inline assembly.

		    One thing to be noticed is that we had to change the
		    assembly to use register si where we had been using bx.

		    See note (6).

		    We alse had to set the location where the call instruction
		    should leave the return address for the callee.


 * eg-10.c	    Like eg-09 but using GCC extended assembly.

   		    Extended assembly allow us to

		      reference C variable within asm code;
		      generate unique labels across the compilation unit;
		      notify GCC about clobbered registers.

		    Build eg-09.bin and compare

   		       make diff eg-09_utils.s eg-10_utils.s

		       make diff eg-09_utils.bin eg-10_utils.bin

		    See how differently GCC handled the asm. In extended asm
		    GCC is allowed to optmize to modify the output. We
		    used volatile with extended asm to prevent optimization.

		    We handled the stack pointer in a better way.

 * eg-11.c	    A program with a familiar C-like look.

   		    We did some changes

		       replaced asm rt0 with a C version
		       used the linker to set the stack location
		       changed functions name to look like C
		       jump to main from rt0
		       add an exit function
		       fixed writing routine not to output 0x0

   		    See comments in the file.

  * eg-12.c	    Finally our masterpiece C-looking program.

    		    An even more tranditional C-like program.

		    We now return from main, rather than calling exit.

		    This time we can't use attribute naked in main();
		    otherwise the compiler removes the 'ret' instruction.
		    The assembly for eg-11.s is added some extra code that
		    is not fundamental here, as explained in eg-07.c comments.

 Troubleshooting
 ------------------------------

 You are encouraged to send boot reports and fixes to the software author.

 Some known issues and tentative workarounds are here listed.

 - Issue: my image boots ok with the emulator but not with the hardware.

   If you have prepared your stick with


      make stick IMG=foo.bin STICK=/dev/sdX

   try then, instead

      make stick IMG=foo.iso STICK=/dev/sdX

 - Issue: I used the regular cp command to transfer image.bin to my stick.

   No, it does not work. Utility cp relies on the OS to transfer data
   to a formatted media. It will choose where to store the data
   and it will certainly not be to the MBR area. You can either
   use cat, dd or, if your BIOS needs, xorriso.


 Notes
 ------------------------------

 (1)   Original PC's BIOS used to read the MBR from the first 512 bytes of
       either the floppy or hard disks. Later on, when CD-ROM technology
       came about, it brought a different specification for the boot
       information, described in the iso9960 (the conventional CD file system
       format). Vendors then updated the BIOSes to detect whether the storage
       is either a floppy (or HD) or a CD-ROM, and apply the appropriate boot
       procedure. More recently, when USB flash devices were introduced, the
       approach adopted by BIOS vendors was not to specify a new boot procedure,
       but to emulate  some of the former devices. The problem is that this
       choice is not very consistent: some BIOSes would detect a USB stick as
       a floppy, whereas other BIOSes would see it as a CD (welcome to the
       system layer!).

       If your BIOS mimics the original PC, to make a bootable USB stick
       all you need to do is to copy the MBR code to its first 512 bytes:


   	  make stick IMG=foo.bin STICK=/dev/sdX


       On the other hand, if your BIOS insists in detecting your USB stick
       as a CD-ROM, you'll need to prepare a bootable iso9660 image as
       described in El-Torito specification [2]. 

       As for that, the GNU xorriso utility may come in handy: it prepares a
       bootable USP stick which should work in both scenarios. Xorriso copies
       the MBR code to the first 512 bytes to the USB stick and, in addition,
       it also transfer a prepared iso9660 to the right location. If you can't
       get your BIOS to boot and execute the example with the above (floppy)
       method, then try

         make stick IMG=foo.iso STICK=/dev/sdX


       We wont cover iso9660 El-Torito boot for CD-ROM, as newer x86-based
       computers now offers the Unified Extensible Firmware Interface meant
       to replace the BIOS interface of the original PC.  EFI is capable
       of decoding a format device, allowing the MBR code to be read from a
       standard file system. Although EFI is gradually turning original PC
       boot obsolete, however, most present day BIOSes offer a so called
       "legacy mode BIOS" and its useful to understand more sophisticated
       technologies, as low-level boot is still often found in legacy
       hardware and embedded systems.



 (2)  One reason we had better switch from nasm (Intel) to gas (AT&T)
      assembly here is because GCC (compiler) and NASM (assembler) do
      not go that well together. Actually, although GCC outputs AT&T syntax
      by default, it is true that GCC is capable of outputing Intel
      assembly if asked by means of the 'masm' option.  The problem is that
      the latter comes in specific Intel assembly dialect meant for GAS
      (GNU Assembler), which is not the same as that understood by NASM
      --- for instance, some directives (such as 'bit 16' vs .code16,
      times vs .fill etc.), data types ('dw' vs 'word'), and mnemonics
      (mov vs moveb, movel etc.) differ.

      A glimpse of those differences may be seen in egx-03.S.

      It's therefore not practical to ask GCC to generate intel assembly
      from C, and have the latter assembled by nasm; we would need to
      use GAS, instead anyway.

      As a side note, that is why we do not refer to assembly as a
      "programming language", in the same way we refer to the C language
      but, as the name implies, as an "assembling language". Diverse
      assembly standards vary in syntax and thereby constitute different 
      specifications. Moreover, the assembly code is dependent on the
      processor architecture e.g. i386 vs ARM etc.

      If we want to read the assembly generated by GCC, even if we ask
      for Intel syntax, we would need to learn a new dialect --- whose
      differences are not only a matter of syntax, but also of semantics.
      For instance, the way NASM compiler works with directive 'org'
      is very different from how GAS works in association to the linker
      (ld) to relocate code.  It so happens that it may be arguably more
      interesting learn the native GCC toolchain assembly dialect and
      proceed therefrom.


 (3)  The ISO C standard specifies the support for the insertion of
      assembly code within the body of a C source code, by means
      of a feature referred to as inline assembly.

      GCC supports inline assembly through the declaration

      __asm__ ("string");

      where "string" is a piece of assembly code. GCC does not
      interpret the contents of the string and output it as is
      in the produced assembly.

      See egx-01.c for an example.

      The code illustrates the user of the qualified 'register' to
      force a variable to allocated in a register rather than in
      work memory (RAM) as it's normally done.  This allows us
      to store a value in the register using the regular variable
      attribution syntax.

      Build it and disassembly with

         make diss IMG=eg-03.bin



 (4) Put short, GCC toolchain is not currently proficient in producing
      propper object code from C inline assembly source code intended
      to manipulate 8-bit registers directly, that is

      register char ax __asm__("ax");

      does not work as expected.

      In order to dig into this issue, it's first useful to understand
      how 8, 16 and 32-bit registers are handled by the x86 architecture.

      Consider either example egx-02-32bit.S, in GAS dialect or, alternatively,
      exg-04-32bit.asm, an equivalent in NASM dialect. The result of the
      experiment should be the same.

      The program instructs the assembler to generate code for a 32-bit
      (x86) CPU. The object code is supposed to store arbitrary values
      in ah, ax and eax.

      Build it and inspect the output with

         make diss IMG=egx-02-32bit-nasm.bin

         or

         make diss IMG=egx-02-32bit-gas.bin


      The output should identical:

         0:	b4 01                	mov    $0x1,%ah
   	 2:	66 b8 02 00          	mov    $0x2,%ax
   	 6:	b8 03 00 00 00       	mov    $0x3,%eax

      Line 0 uses opcode 0xb4 to store 1 in ah; the same we've got when
      we compiled eg-04.asm or eg-05.S. This instruction takes 1 byte
      as argument.

      Line 6 uses the opcode 0xb8 to store 3 in eax. This instruction takes
      4 bytes as argument.

      Now look at line 6. It is supposed to store 2 in ax and needs 2 bytes
      as argument. This would sum up 3 bytes, but the line is 4-bytes long.
      Staring at the last byte in the line and moving backwards, we can
      clearly identify the instruction 0xb8, the same as in line 6, and
      the 2-byte representation of 0x2 in little endian.

      But as we've seen, 0xb8 takes 4-bytes and store in eax. What is
      happening here? Well, look at the first byte at line 2, the one
      preceding the 0xb8 instruction. It is a instruction prefix.
      More specifically, 0x66 is a "Operand size overwrite" prefix.
      Its effect is to toggle the normal (non-prefixed) length of the
      next instruction's argument. In this case, from 32-bit to 16-bit.

      This is how the 32-bit x86 architecture stores a value in a 16-bit
      register in our example. While for ah and eax the assembler uses
      different opcodes for the respective operations, for ax it uses
      the same instruction that is used for eax, but with a operand
      size overwrite prefix.

      Now let's do the same thing with egx-02-16bit.asm.

         make diss IMG=egx-02-32bit-nasm.bin 16

         or

         make diss IMG=egx-02-32bit-gas.bin 16

      The only different from the previous 32bit versions is the directive
      to select 16 bits, but the disassembly shows
      

         0:	b4 01                	mov    $0x1,%ah
   	 2:	b8 02 00             	mov    $0x2,%ax
   	 5:	66 b8 03 00 00 00    	mov    $0x3,%eax

      Compare to the previous result:

         0:	b4 01                	mov    $0x1,%ah
   	 2:	66 b8 02 00          	mov    $0x2,%ax
   	 6:	b8 03 00 00 00       	mov    $0x3,%eax

      Line 0 has not changed.

      Line 2, however, has. It lost the operand size overwrite prefix, which
      passed to the line 6.

      This time, we told the assembler we were targeting a 16-bit (8080)
      CPU. Instruction 0xb4 works as usual. But now the normal (non-prefixed)
      default argument length of 0xb8 is 2-bytes (16 bits). It's the manipulation
      of eax (32 bits) that need the operand size overwrite prefix.

      Why x86 code reuses the same instruction to move to ax and eax, by means
      of prefixes, rather than having a specific instruction for each? This is
      a design decision. But it's not hard to notice that eax and ax are,
      after all, portions of the same 64-bit register found in x86_64. It may
      make sense from the hardware design perspective.
      
      Well, so far so good.

      But what is the problem with manipulating 8-bit registers with inline
      assembly anyway?

      Now GCC's own quirks come into play.

      Consider the example egx-07.c.

      We use inline assembly to force the variables to be allocated into
      registers (see note 3a).

      Now build and inspect with

         make egx-07-16bit.bin/diss 16

         0:	66 bb 01 00 00 00    	mov    $0x1,%ebx
   	 6:	66 b8 02 00 00 00    	mov    $0x2,%eax
   	 c:	66 b8 03 00 00 00    	mov    $0x3,%eax
  	 12:	66 b8 04 00 00 00    	mov    $0x4,%eax
  	 18:	90                   	nop
  	 19:	0f 0b                	ud2    

	 
      Line 0 uses 0x66 prefix to store the next 4 bytes in bx, discarding
      the remaining two. Line 6 does the same with for ax.

      Now see line c. It should store 1 byte in ah. However it's just another
      0xb8 move instruction prefixed to store the next two bytes in eax.
      The same as 'mov $0x3, ax'. Line 12, likewise, will store in eax,
      overriding anything we had put in ah in the previous step.

      If we had written the assembly manually as in egx-02, we would have used
      'mov $0x3, %ah' and this would have resulted in a 0xb4 instruction as before.

      But this is not what GCC itself does. Just build both the 16 and 32-bit
      versions of the same example

      	 make egx-07-32bit.bin

      	 make egx-07-16bit.bin

      And see the generated assembly files

        cat egx-07-32.bit.s
        cat egx-07-16.bit.s
	
      or

        diff egx-07-32.bit.s egx-07-16.bit.s
     

      and observe that the only different is the directive .cod116gcc.

      As we can notice, GCC always use the 32-bit registers and rely on GAS
      to honor the 16-bit directive.

      We can see the result by comparing

      	 make egx-07-16bit.bin/diss 16
      	 make egx-07-32bit.bin/diss 32


      The conclusion is that the code is not honoring what the C source says.
      This is a known issue and not exactly a bug, seen that GCC does not
      even claim the support to operate with 8-bit register variables. We
      are pushing it too hard.  There are other C compilers out there
      which do support this kind of operation, but if we are to explore
      GCC, we should avoid manipulating 8-bit register variables.
      

(5)   Consider program egx-05.c.

      If we trust that register variables can be safely manipulated as
      regular memory-allocated variables, we would expect that by the
      end of the program we have 0x1 stored in eax and 0x2 stored in ebx.
      
      This is 32-bit program. What could possible go wrong.

      To answer the question you may

      	 make egx-05.bin/run

      and then, in qemu, press Ctr-Alt-2 to invoke the debug console.
      Then type

         print $eax
	 print $ebx

      to inspect the values stored in the registers: both have 0x2.

      Why is that?  Make

         make eg-05.bin/diss 32

      and go through the diassembly

            0:	b8 01 00 00 00       	mov    $0x1,%eax
   	    5:	83 c0 01             	add    $0x1,%eax
   	    8:	89 c3                	mov    %eax,%ebx


      Line 0 implements the C source statement

      	   eax = 1;

      In order to implement the next C statement

           ebx = eax + 1;

      line 5 first add 1 to eax, and then move eax to ebx.

      The compiler has absolutely no obligation to fulfill our expectations
      regarding the assembly it generates. It might well had made

      	   mov $0x01, %eax
	   mov %eax, %ebx
	   add $0x1, %ebx

     and we would have 1 in eax, and 2 in ebx. But the compiler is free
     to choose whatever assembly it feels like, as long as the attributions
     we specified are correct. The analogy with memory variables is a
     potentially misleading idea if not reasoned with due care.

     Usually, we use basic inline assembly withing C functions only when
     assembly is the only code withing the function.

     That said, GCC has support for another form of inline assembly
     called extended nasm, which allow for mixing C and assembly
     with the due meticulous care.

 (6)  Previously, we would do
		    
      		    AT&T syntax			Intel syntax

      		    msg(%bx)			[msg + bx]


      to iterate through the characters of the string located at msg, using bx
      as the index of the array.

      Now, rather than constant labeled position, our string may be anywhere
      and we pass it to the function as an address stored in %cx. The thing
      is, we can't do

		    AT&T syntax			Intel syntax

		    %cx(%bx)			[cx + bx]
		    
      Why not? Because the i8086 (16-bit precursos of x86) does not allows to.
      The way to traverse an array here is by using the base-index-scale

		  base address + index array * scale

      E.g.

		   (%bx, %si, 1)

      is the memory position starting from the base address %bx, advancing
      %si * 1 positions.  The scale may be e.g. 4 if we want to advance
      %si 32-bit integers.

      So, in our example, can we do

		  (%cx, %bx)

       No.

       In 16-bit real mode x86 allow us We limited choices

	     	   (%bx), (%bp), (%si), (%di),

	           (%bx,%si), (%bx,%di), (%bp,%si) and (%bp,%di)


        We than had to modify our code to use %si for iteration and %bx for
	the base. (Do the respective names "base register" and "source  index 
	register" for bx and si ring you a bell?)

	Do I really need to know all of this??? 

	Hump... know this you must, for intricate and deceptive the hardware
	may be... and fighting the darkness you shall, to bring consistency
	and balance where there would be only chaos and fear.


 References
 ------------------------------
 
 [1] Auxiliary program: syseg/src/hex2bin

 [2] El-Torito: https://wiki.osdev.org/El-Torito