
 OVERVIEW
 ------------------------------

 In order to experiment with the examples in this section, the following
 pieces of software are required. The version indication lists those with
 which the project was tested. Using a more recent version should be
 ok, but it is not absolutely guaranteed that results may exhibit minor
 variations. Feedback is always appreciated.

 - GCC 	     	 9.3.0
 - binutils 	 2.34
 - nasm		 2.14.02
 - qemu		 4.2.1		(qemu-system-i386)
 - gcc-multilib  9.3.0		(to compile 32-bit code in a 64-bit platform)

 If you may also need

 - xoriso	1.5.2-1		(depending on your computer's BIOS)


 BUILD DIRECTIONS
 ------------------------------

 Use

   make name.bin		             build name.bin 

   make run IMG=name.bin	             test name.bin with the emulator

   make diss IMG=name.bin	             disassemble name.bin

   make dump IMG=name.ext	             dump the raw contents of name.ext

   make      			             build everything (or make all)

   make clean			             undo make all

   make help			             usage information

   make iso IMG=name.iso	             build a iso9660 image with name.bin

   make stick IMG=name.bin STICK=/dev/sdX    make a bootable USB stick


 Some examples allow alternative build recipes which can be selected
 by passing the command-line variable ALT=<number> to make. See bellow. 

 Files

     eg-00.ext		contain the main examples;
     egx-00.ext		contain auxiliary extra examples.

 Extension

     hex		indicates an ASCII file containing values
     			in hexadecimal representation;

     asm		indicates manually written assembly code in
     			Intel ASM format;

     S			indicates manually written assembly code
     			in AT&T Gas format;

     s			indicates assembly code in AT&T Gas format
     			generated by the compiler (GCC);

     o			indicates object code produced by the assembler;

     bin		indicates binary file generated by the
     			compiler /linker;

     ld			indicates a linker script.


 Note on booting the real hardware

    Unfortunately, not all BIOSes  handle USB boot devices in the same
    way (welcome to system level). Some are likely to emulate it as a floppy
    disk and rely on the original IBM PC boot method we are exploring here.
    If so, you should be able to prepare your stick using 'make stick'
    with the command line variable IMG=name.bin. Otherwise, if your computer's
    BIOS emulates your USP stick as a CD-ROM, you should be better served
    by passing it the variable IMG=name.iso.  See note (1) by the end.


 Words of wisdom

    If you plan to boot the examples in the physical hardware, check which
    device represents your USB stick. You may use, for instance lsblk utility.
    Your devices should possibly list as /dev/sdX, with X being a, b, c etc.

    If you have only one storage device, say your HD, it may appear as
    /dev/sda, and when you plug your USB stick, it'll take the next
    available letter and appears as /dev/sdb.  

    Be careful. If you misspell your stick as /dev/hda, you may hopelessly
    grief in pitiful misery for a long time... 

 CONTENTS
 ------------------------------

 Take a look at the following examples.
 


 * eg-01.hex	    Bare-metal hardcore Hello World in machine code.
 
   		    This is a tough old-school version of the classical
		    Hello World program. It writes the string directly to the
		    BIOS video memory, character by character, one at a time.
		    A Hello World as you may have never made before, with
		    neither an OS, nor a programming language, not even
		    assembly; just bare machine code.

		    The source code is an ASCII file containing the opcodes of
		    the program in hexadecimal representation.

		    Build with it with a simple hex-to-binary converter. 


 * eg-02.asm	    The same as eg-01.hex, but now in assembly code.

   		    This program implements literally the same algorithm as
		    eg-01.hex, but written in assembly code, using Intel
		    syntax. This is the assembly understood by NASM assembler,
		    used here to build the binary.

		    Compare eg-01.bin and eg-02.bin with

		    $ make diss IMG=eg-01.bin
		    $ make diss IMG=eg-02.bin

		    and see that the resulting object codes match.


 * eg-03-beta.asm   A variation of eg-02.asm, using a loop.

  		    Notice that now that we are dealing with offsets, we must
		    beware of the RAM load address.
		    
 * eg-03.asm	    Same as eg-03-beta.asm, but using the 'org' directive.

   		    The directive 'org' causes all labels to be offset
		    to match the position where BIOS loads the program.

   		    Now it's time to bear in mind that asm is performing
		    both the assembling (object code generation) and
		    linking (build-time address relocation) steps.


* eg-04.asm	    A more elegant version of eg-03, just with neater code.

		    Compare eg-03.bin and eg-04.bin with

		    $ make diss IMG=eg-03.bin
		    $ make diss IMG=eg-04.bin
  		    
		    and see that the resulting object codes match.

* eg-05-beta.1.S    Like eg-05.asm, but translated into AT&T assembly syntax.

  		    One motivation to convert the assembly source code from
		    Intel to AT&T syntax is because we intend to rewrite
		    the running example in C language.  To that end, we will
		    use the powerful and flexible GNU compiler collection.
		    The thing is, GCC's toolchain speaks AT&T sysntax dialect
		    and does not understand NASM's dialect.  See note 2 for
		    further detailing.

   		    The translation was made as literal as possible so as to
		    facilitate the comparison with eg-04.asm.

		    Compare eg-03.bin, eg-05.bin and eg-05.bin with

		    A noteworthy observation is that the build procedure of
		    this example involves two steps: assembling and linking.
		    With NASM, which we had been using previously, those
		    two steps were performed by the same program. In the GNU
		    development toolchain they are performed by distinct
		    program. The GAS assembler (as) convert assembly to
		    object code (machine code), and then the linker is used
		    to remap the addresses offset to match the RAM load
		    address (we pass it as command line argument to the linker
		    rather than via an inline directive).


* eg-05-beta.2.S   Same as before, but using global symbol for entry point.

   		    This example is just to illustrate that the linker can
		    recognize the entry point as a label, rather than through
		    the absolute offset.

 * eg-05.S	    Same as before, but with standard entry point name.

   		    This example is to illustrate that the default symbol name
		    for the entry point is __start. If we stick to it, we do
		    not need to pass it as an option for to the linker. Later
		    on, we'll see that the assembly generated by C compiler
		    has an entry point with that name.

		    Alternative:

		    Issuing the build rule with the command-line variable
		    ALT=1 selects an alternative recipe using a single GCC 
		    invocation (GCC then invokes assembler and linker with
		    appropriate arguments).


		    $ make diss IMG=eg-03.bin
		    $ make diss IMG=eg-04.bin
		    $ make diss IMG=eg-05.bin

		    and see that they all match.


* eg-06.S	    Program eg-06.S modified to manipulate 32-bit registers.

		    The mean reason to rewrite eg-05.S using 32-bit registers
		    is because GCC does not do a good job producing 16-bit
		    assembly code. In order to mix C and inline assembly
		    as we'll shall do next, we'd better modify our code
		    to manipulate 32-bit registers and leave to the assemlber
		    the duty of produce appropriate 16-bit object code.
		    
		    To better understand this limitation, refer to note 3
		    by the end of this file.
		    
		    Alternative:

		    Issuing the build rule with the command-line variable
		    ALT=1 selects an alternative recipe using a single GCC 
		    invocation (GCC then invokes assembler and linker with
		    appropriate arguments).

* eg-07-beta.c	    Like eg-06.S, but translated into C.

   		    We use basic inline assembly.

		    Alternatives:

		    b) Issuing the build rule with the command-line variable
		    ALT=1 selects an alternative recipe using a linker
		    script which stands in for some of the compiler's and
		    linker's flags, in particular, the instructions to
		    generate flat binary, set entry point and copy only
		    the code (.text) section to the output.

		    a) Issuing the build rule with the command-line variable
		    ALT=1 selects an alternative recipe using a single line
		    compiler (gcc) invocation.

		    Note that the string is now allocated in the read-only
		    section of the object code --- and also the ad hoc
		    workaround we used.

 * eg-07.c	    Like eg-07-beta.c, but handling .rodata with the ld script

   		    It is now opportune to verify what has being said in the
		    comments of eg-05.S, about GCC not being found of 16-bit
		    assembler. See note 5.


 * eg-08.c	    Like eg-08.S


 Troubleshooting
 ------------------------------

 You are encouraged to send boot reports and fixes to the software author.

 Some known issues and tentative workarounds are here listed.

 - Issue: my image boots ok with the emulator but not with the hardware.

   If you have prepared your stick with


      make stick IMG=name.bin STICK=/dev/sdX

   try then, instead

      make stick IMG=name.iso STICK=/dev/sdX

 - Issue: I used the regular cp command to transfer image.bin to my stick.

   No, it does not work. Utility cp relies on the OS to transfer data
   to a formatted media. It will choose where to store the data
   and it will certainly not be to the MBR area. You can either
   use cat, dd or, if your BIOS needs, xorriso.


 Notes
 ------------------------------

 (1)   Original PC's BIOS used to read the MBR from the first 512 bytes of
       either the floppy or hard disks. Later on, when CD-ROM technology
       came about, it brought a different specification for the boot
       information, described in the iso9960 (the conventional CD file system
       format). Vendors then updated the BIOSes to detect whether the storage
       is either a floppy (os HD) or a CD-ROM, and apply the appropriate boot
       procedure. More recently, when USB flash devices were introduced, the
       approch adopted by BIOS vendors was not to specify a new boot procedure,
       but to emulate  some of the former devices. The problem is that this
       choice is not very consistent: some BIOSes would decect a USB stick as
       a floppy, whereas other BIOSes would see it as a CD (welcome to the
       system layer!).

       If your BIOS mimics the original PC, to make a bootable USB stick
       all you need to do is to copy the MBR code to its first 512 bytes:


   	  make stick IMG=name.bin STICK=/dev/sdX


       On the other hand, if your BIOS insists in detecting your USB stick
       as a CD-ROM, you'll need to prepare a bootable iso9660 image as
       described in El-Torito specification [2]. 

       As for that, the GNU xorriso utility may come in handy: it prepares a
       bootable USP stick which should work in both scenarios. Xorriso copies
       the MBR code to the first 512 bytes to the USB stick and, in addition,
       it also transfer a prepared iso9660 to the right location. If you can't
       get your BIOS to boot and execute the example with the above (floppy)
       method, then try

         make stick IMG=name.iso STICK=/dev/sdX


       We wont cover iso9660 el-torito boot for CD-ROM, as newer x86-based
       computers now offers the Unified Extensible Firmware Interface meant
       to replace the BIOS interface of the original PC.  EFI is capable
       of decoding a format device, allowing the MBR code to be read from a
       standard file system. Although EFI is gradually turning original PC
       boot obsolete, however, most present day BIOSes offer a so called
       "legacy mode BIOS" and its useful to understand more sophisticated
       technologies, as low-level boot is still often found in legacy
       hardware and embedded systems.



 (2)  One reason we had better switch from nasm (Intel) to gas (AT&T)
      assembly here is because GCC (compiler) and NASM (assembler) do
      not go that well together. Actually, GCC outputs AT&T syntax
      by default, but it is indeed capable of outputing Intel assembly
      if asked, by means of the 'masm' option.  The problem is that the
      latter comes in specific Intel assembly dialect meant for GAS
      (GNU Assembler), which is not the same as that understood by NASM
      --- for instance, some directives (such as 'bit 16' vs .code16,
      times vs .fill etc.), data types ('dw' vs 'word') differ and
      mnemonics (mov vs moveb, movel etc.) It's therefore not possible
      to ask GCC to generate intel assembly from C, and have the latter
      asesmbler by nasm; we would need to use GAS, instead.

      As a side note, that is why we do not refer to assembly as a programming
      language, in the same way refer to the C language but as, as the name
      suggest, as assembling language. Both the syntax of different assembly
      standard vary and constitutes therefore different specifications.
      Moreover, the assembly code is dependent on the processor architecture
      e.g. i386 vs ARM etc.

      If we want to see the assembly generated by GCC, even if we ask
      for Intel syntax, we would need to learn a new dialect --- whose
      difference is not only a matter of syntax, but also of semantics
      For instance, the way NASM compiler works with directive 'org'
      is very different from how GAS works in association to the linker
      (ld) to relocate code.  It so happens that it may be arguably more
      interesting learn the native GCC toolchain assembly dialect and
      proceed therefrom.

 (3)  Put short, GCC does not currently produces 16-bit assembly code.
      Yes, GCC does create 16-bit binaries but to that end, it produces
      an assembly which used 32-bit registers, and rely on GAS to 
      fix the assembly into a 16-bit binary. For instance, if the C code
      should translate into a 16-bit machine code equivalent to

         mov ax, 0x1

      GCC, event with the option -m16, may well output

         mov eax, 0x01

     and leave a directive (.code16gcc) in the assembly file. In the
     subsequent step, GAS will find this directive and honor it by
     producing a 16-bit machine code.

     One may verify this by building the auxiliary extra examples

     	 make egx-01-16.bin
 	 make egx-01.32.bin

     and inspecting the produced assembly codes

     	 diff -y --color egx-01-16.s egx-01.32.s

     Both should differ only in the line corresponding to the assembler
     directive for 16-bit code.  Note that the C-source code line

     	 return 42

     is transformed into the assembly code line


         mov $42, %eax 

     The directive .code16gcc is passed to the assembply, which is then
     in charge of generating the corresponding instructions for 16-bit.


     Now, inspect the corresponding object code generated by the assembler.

     	 diff --color <(make diss IMG=egx-01-32.bin) \
	              <(make diss IMG=egx-01-16.bin)

     See that in the 32-bit version, the aforementioned instruction does
     reproduce the input assembly source

         mov $0x2a, %eax

     whereas in the 16-bit version, the disassembly shows

     	 mov $0x2a, %ax

     The reason why GCC does not output 16-bit assembly has to do with
     design decisions and priorities of the project.
     

     #####

       Compare

       meld <(make diss   IMG=egx-01-16.bin) \
            <(make diss16 IMG=egx-01-16.bin)\
	    <(make diss   IMG=egx-01-32.bin)

       16-bit code is generated with prefixes to regular 32-bit instructions,
       what is different from manually written 16-bin assembly.




 (5) Consider the auxiliary example code egx-02.c.

     


 References
 ------------------------------
 
 [1] Auxiliary program: syseg/src/hex2bin

 [2] El-Torito: https://wiki.osdev.org/El-Torito