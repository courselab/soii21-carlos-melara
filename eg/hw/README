
 CONTENTS
 ------------------------------

 Take a look at the following examples.

 * eg-01.hex 	    A minimal bootable program written directly in machine code.
 
		    The source code is an ASCII file containing the opcodes of
		    the program in hexadecimal representation. This program
		    contains only the boot signature and implements no other
		    behavior. Build with it with a simple hex-to-binary
		    conversion and run to see if the MBR is detected.


 * eg-02.hex	    Bare-metal hardcore Hello World in machine code.
 
   		    This is a tough old-school version of the classical
		    Hello World program. It writes the string directly to the
		    BIOS video memory, character by character, one at a time.
		    A Hello World as you have never made before, for the
		    braves. 


 * eg-03.asm	    The same Hello World, but now in assembly code.

   		    This program implments literally the same algorithm as
		    eg-02.hex, but written in assembly code, intel syntax.
		    Use nasm assembler to build the binary (see note 1).

		    Compare eg-02.bin and eg-03.bin with

		    $ make dump IMG=eg-02.bin
		    $ make diss IMG=eg-03.bin


 * eg-04-beta.asm   A variation of eg-03.asm, using a loop.

  		    Notice that now that we are dealing with offsets, we must
		    beware of the RAM load address. All labels should be
		    offset to match the position where BIOS loads the program.

 * eg-04.asm	    Same as eg-04-beta.asm, but using the 'org' directive.

   		    Now it's time to bear in mind that asm is performing
		    both the assembling and linking steps.

 * eg-05.asm	    A more elegant version of eg-04, just with neater code.

		    Compare eg-04.bin and eg-05.bin with

		    $ make dump IMG=eg-04.bin
		    $ make diss IMG=eg-05.bin
  		    
 * eg-06-beta.1.S   Like eg-05.asm, but translated into AT&T assembly syntax.

   		    The translation was made as literal as possible so as to
		    facilitate the comparision. One motivation for using AT&T
		    syntax is to allow for the utilization of GNU development
		    toolset (e.g. GCC) and explore its sophisticated
		    capabilites --- which should come in handy to port the
		    source code of the running to C language, with the aid of
		    inline assembly and other useful features.
		    
		    One could well ask why we can't just use GCC to convert
		    from C to assembly, and then just use NSAM to perform
		    assemlbing and linking as before? Well, it is because the
		    assembly generated by GCC from C does not goes well with
		    NASM. See note 2 bellow for further detailing.

		    Compare eg-04.bin, eg-05.bin and eg-05.bin with

		    $ make diss IMG=eg-04.bin
		    $ make diss IMG=eg-05.bin
		    $ make diss IMG=eg-05.bin

		    and see that they all match.

		    A noteworthy observation is that the build procedure of
		    this example involves two steps: assembling and linking.
		    With NASM, which we had been using previously, those
		    two steps were performed by the same program. In the GNU
		    development toolchain they are performed by distinct
		    program. The GAS assembler (as) convert assembly to
		    object code (machine code), and then the linker is used
		    to remap the addresses offset to match the RAM load
		    address (we pass it as command line argument to the linker
		    rather than via an inline directive).

 * eg-06-beta.2.S   Same as before, but using global symbol for entry point.

   		    This example is just to illustrate that the linker can
		    recognize the entry point as a label, reather than through
		    the absolute offset.

 * eg-06.S	    Same as before, but with standard entry poing name.

   		    This example is to illustrate that the dafult symbol name
		    for the entry point is __start. If we stick to it, we do
		    not need to pass it as an option for to the linker. Later
		    on, we'll see that the assembly generated by C compiler
		    has an entry point with that name.
		    
 * eg-06+1.bin	    Building eg-06.S with one-line GCC invocation.

   		    There is no source example named eg-06+1.S. We just
		    compile eg-06.S using a single command line. GCC, in turn,
		    invokes the assembler (gas) and the linker (ld) with
		    appropriate command line options. See Makefile.

 * eg-07.S	    Program eg-06.S modified to manipulate 32-bit registers.

    		    Why that? The main reason is that we want to use GCC
		    to produce 16-bit assembly, which we can further
		    process with GAS. However, GCC does not do a good job
		    producing 16-bit assembly code. It works very well for
		    32-bit and 64-bit but not with 16-bit. To better
		    understand it, see note 3 ahead.
  
 * eg-08.c	    Like eg-07.S, but translated into C.

   		    We use basic inline assembly.


 Notes
 ------------------------------

 (1) As a side note, we do not refer to assembly as a programming language
     in the same way refer to the Clanguage. First, the assembly menonics
     depend on the opcodes of target processor e.g. i386, ARM etc. ---
     not to mention 16, 32, 64-bit registers etc. Second, even with respect
     to one processor, there are different syntaxes such as Intel and AT&T.
     And, even more, different assemblers (piece of software which generates
     machine code from the assembly code) implement their own dialects. For
     instance, GNU assembler (gas) can read Intel assembly syntax, but in
     a different dialect (minor syntax incongruences) than that used by
     NASM assembler.


 (2)  One reason we had better switch from nasm (Intel) to gas (AT&T)
      assembly here is because GCC (compiler) and NASM (assembler) do
      not go that well together. Wheares GCC ouputs AT&T syntax by default,
      it does is capable of outputing Intel assembly if asked by means
      of 'masm' option.  The problem is that the latter comes in a
      specific intel assembly dialect meant for GAS (GCC toochain),
      which is not the same as that understood by NASM. And NASM does not
      understand GCC's AT&T assembly either.  Because of this, we can not
      take the assembly produced by GCC and feed it into nasm. Thus, if
      we intend to write in C and compile with GCC, we are compelled
      to use GAS --- and thereby AT&T assembly.  The alternative to
      keep NASM would be to change the C compiler (indeed, I have tried
      without success to use TCC and BCC, but at the end of the day,
      GNU development toolset turned a lot more appealing for the
      present purpose).

      Indeed, there is another reason NASM do not work well with GCC's inline
      assembly, and this has to do with the reasons layed in note 3.
      
 (3)  Put short, GCC does not currently produces 16-bit assembly code.
      Yes, GCC does create 16-bit binaries but to that end, it produces
      an assembly which used 32-bit registers, and rely on GAS to 
      fix the assembly into a 16-bit binary. For instance, if the C code
      should translate into a 16-bit machine code equivalent to

         mov ax, 0x1

      GCC, event with the option -m16, may well output

         mov eax, 0x01

     and leave a directive (.code16gcc) in the assembly file. In the
     subsequent step, GAS will find this directive and honor it by
     producing a 16-bit machine code.

     One may verify this by writing the followin exampe foo.c

        int foo (int x)
        {
          return x+1;
        }

     building it with

         gcc -m32 -S -masm=intel -fno-pic foo.c -o foo-32.s
         gcc -m16 -S -masm=intel -fno-pic foo.c -o foo-16.s

	 as --32 foo-32.s -o foo-32.bin
	 as --32 foo-16.s -o foo-16.bin

     and inspect both assemblys and both objects with

         objdump -M intel -d foo-32.bin
         objdump -M intel -d foo-16.bin

     Note that both assembly sources differs only in the directive
     for 16-bit, while the binaries do make use of 32-bit and
     16-bit, respectively.

     The reason why GCC does not output 16-bit assembly has to do with
     design decisions and priorities of the project. 


 References
 ------------------------------
 
 [1] Auxiliary program: syseg/src/hex2bin
