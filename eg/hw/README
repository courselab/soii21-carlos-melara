
 OVERVIEW
 ------------------------------

 In order to experiment with the examples in this section, the following
 pieces of software are required. The version indication lists those with
 which the project was tested. Using a more recent version should be
 ok, but it is not absolutely guaranteed that results may exhibit minor
 variations. Feedback is always appreciated.

 - GCC 	     	 9.3.0
 - binutils 	 2.34
 - nasm		 2.14.02
 - qemu		 4.2.1		(qemu-system-i386)
 - gcc-multilib  9.3.0		(to compile 32-bit code in a 64-bit platform)

 If you may also need

 - xorriso	1.5.2-1		(depending on your computer's BIOS)


 BUILD DIRECTIONS
 ------------------------------

 Use

   make foo				     Build foo.

   make run IMG=foo	             	     Test foo with the emulator.

   make diss IMG=foo 			     Disassemble foo.

   	     	     			     Optionally,

					        NASM = intel | att  (default)
						BIT  =    16 | 32   (default)

   make dump IMG=foo			     Show the raw contents of foo.
   
   make      			             build everything (or make all)

   make clean			             undo make all

   make stick IMG=foo STICK=/dev/sdX         make a bootable USB stick

   make iso IMG=foo	             	     build an iso9660 image with foo

   SHORTCUTS

   make foo/diss			     disassembly as 32-bit AT&T
   make foo/diss intel|att		     disassembly as 32-bit Intel or AT&T
   make foo/diss 16|32			     disassembly as 16-bit or 32-bit
   make foo/diss intel\att 16|32	     disassembly as Intel|AT&T 16|32 bit
   make foo/diss 16|32 intel|att	     disassembly as Intel|AT&T 16|32 bit

   make foo/i16	       			     disassembly as Intel 16-bit
   make foo/i32	       			     disassembly as Intel 32-bit
   make foo/a16	       			     disassembly as AT&T  16-bit
   make foo/a32	       			     disassembly as AT&T  32-bit

   make foo/dump			     show raw contents in hexadecimal

   make foo/run				     test foo with the emulator


 Some examples allow alternative build recipes which can be selected
 by passing the command-line variable ALT=<number> to make. See bellow. 

 File names:

     eg-00.ext		contain the main examples;
     egx-00.ext		contain auxiliary extra examples.

 File extensions:

     hex		ASCII file containing values
     			in hexadecimal representation;

     asm		manually written assembly code in
     			Intel ASM format;

     S			manually written assembly code
     			in AT&T Gas format;

     s			assembly code in AT&T Gas format
     			generated by the compiler (GCC);

     o			object code produced by the assembler;

     bin		binary file generated by the
     			compiler /linker;

     ld			linker script.



 Note on booting the real hardware

    Unfortunately, not all BIOSes  handle USB boot devices in the same
    way (welcome to system level). Some are likely to emulate it as a floppy
    disk and rely on the original IBM PC boot method we are exploring here.
    If so, you should be able to prepare your stick using 'make stick'
    with the command line variable IMG=foo.bin. Otherwise, if your computer's
    BIOS emulates your USP stick as a CD-ROM, you should be better served
    by passing it the variable IMG=foo.iso.  See note (1) by the end.


 Words of wisdom

    If you plan to boot the examples in the physical hardware, check which
    device represents your USB stick. You may use, for instance lsblk utility.
    Your devices should possibly list as /dev/sdX, with X being a, b, c etc.

    If you have only one storage device, say your HD, it may appear as
    /dev/sda, and when you plug your USB stick, it'll take the next
    available letter and appears as /dev/sdb.  You should be required
    administrative privileges (sudo) to write directly into your device.

    Be careful: you're entering system-level. 

    If you misspell your stick as /dev/hda, you may end up grieving in
    pitiful misery and hopeless regrets... do not lower your guard.

    

 CONTENTS
 ------------------------------

 Take a look at the following examples.
 


 * eg-01.hex	    Bare-metal hardcore Hello World in machine code.
 
   		    This is a tough old-school version of the classical
		    Hello World program. It writes the string directly to the
		    BIOS video memory, character by character, one at a time.
		    A Hello World as you may have never made before, with
		    neither an OS, nor a programming language, not even
		    assembly; just bare machine code.

		    The source code is an ASCII file containing the opcodes of
		    the program in hexadecimal representation.

		    Build with it with a simple hex-to-binary converter. 


 * eg-02.asm	    The same as eg-01.hex, but now in assembly code.

   		    This program implements literally the same algorithm as
		    eg-01.hex, but written in assembly code, using Intel
		    syntax. This is the assembly understood by NASM assembler,
		    used here to build the binary.

		    Compare eg-01.bin and eg-02.bin with

		      make diss IMG=eg-01.bin intel 16
		      make diss IMG=eg-02.bin intel 16

		    and see that the resulting object codes match.

		    We are forcing the disassembler to interpret the object
		    as machine code for a i8086 (16-bit) CPU.


 * eg-03-beta.asm   A variation of eg-02.asm, using a loop.

  		    Notice that now that we are dealing with offsets, we must
		    beware of the RAM load address.
		    
 * eg-03.asm	    Same as eg-03-beta.asm, but using the 'org' directive.

   		    The directive 'org' causes all labels to be offset
		    to match the position where BIOS loads the program.

   		    Now it's time to bear in mind that asm is performing
		    both the assembling (object code generation) and
		    linking (build-time address relocation) steps.


* eg-04.asm	    A more elegant version of eg-03, just with neater code.

		    Compare eg-03.bin and eg-04.bin with

		      make diss IMG=eg-03.bin intel 16
		      make diss IMG=eg-04.bin intel 16
  		    
		    and see that the resulting object codes match.

* eg-05-beta.1.S    Like eg-05.asm, but translated into AT&T assembly syntax.

  		    One motivation to convert the assembly source code from
		    Intel to AT&T syntax is because we intend to rewrite
		    the running example in C language.  To that end, we will
		    use the powerful and flexible GNU compiler collection.
		    The thing is, GCC's toolchain speaks AT&T syntax dialect
		    and does not understand NASM's dialect.

		    See note (2) for further detailing.

   		    The translation was made as literal as possible so as to
		    facilitate the comparison with eg-04.asm.

		    A noteworthy observation is that the build procedure of
		    this example involves two steps: assembling and linking.
		    The former translates assembly to object (machine) code,
		    and the latter remaps offsets to match the load address.
		    Those are the normal duties of the assembler and the linker.
		    With NASM, which we had been using previously, those
		    two functions are performed by the same program. In the
		    GNU development toolchain, differently, those duties are
		    performed by two distinct programs: the assembler (GAS,
		    whose executable program name is 'as') converts assembly
		    to object code (machine code), and then the linker (ld)
		    is used to remap the addresses offset to match the RAM
		    load address. GAS does not have an equivalent for the
		    .org directive that we used with NASM for this purpose;
		    we inform the linker directly via a command line option.

		    Moreover, whilst we had instructed NASM to produce a flat
		    binary, the version of GAS installed in our x86 / x86_64
		    platform outputs binaries in ELF format --- a structured
		    executable format that has much more than the executable
		    code section (e.g. header, relocation information and
		    other metadata). It is the liker who is responsible to
		    strip all extra sections and output a flat binary.
		    We tell ld to do that using another command-line option.

		    Finally, ld let us specify which will be the entry point
		    of the executable. This would be important for structured
		    file formats such as ELF (Linux) or PE (windows). For
		    us, it's the first byte. Since ld expects it, we pass
		    this information in yet another command-line option.


 * eg-05-beta.2.S   Same as before, but using global symbol for entry point.

   		    This example is just to illustrate that the linker can
		    recognize the entry point as a label, rather than through
		    the absolute offset.

 * eg-05.S	    Same as before, but with standard entry point name.

   		    This example is to illustrate that the default symbol name
		    for the entry point is __start. If we stick to it, we do
		    not need to pass it as an option for to the linker. Later
		    on, we'll eventually see that the compiler (GCC) is smart
		    enough so as to do the same.

		    Alternative:

		    Issuing the build rule with the command-line variable
		    ALT=1 selects an alternative recipe using a single GCC 
		    invocation (GCC then invokes assembler and linker with
		    appropriate arguments).


		    $ make diss IMG=eg-03.bin intel 16
		    $ make diss IMG=eg-04.bin intel 16
		    $ make diss IMG=eg-05.bin intel 16

		    and see that they all match.

 * eg-06.S	    Like eg-05.S, but modified to manipulate 16-bit registers.

   		    Here we implement the same algorithm as in eg-05.S, but
		    with an alternative code to read and write in both 8-bit
		    registers ah and al by means of manipulating the 16-bit
		    register ax, rather than accessing its higher and lower
		    bytes of directly. 

		    The main reason for doing this, despite the need of some
		    gimmick with bitwise logic operation and an extra register,
		    is because we intend to port our source code from assembly
		    to C and use GNU toolchain to build it.

		    See note (3) for a glimpse on how it would look like.

		    It so happens that GCC does not do a good job working with
		    8-bit registers. As we are taking steps to convert our
		    assembly example into C, limitation will eventually get in
		    our way when we start to experiment with C inline assembly.

		    See note (4) to better understand the issue.
		    		    
		    In order to overcome the limitation, we'd better modify
		    our code to manipulate only 16-bit registers.		    

		    Build eg-06.bin and inspect it with

		       make diss IMG=eg-06.bin 32

		    Why are we forcing the disassemble to interpret the object
		    as a 32-bit code? Because GAS assumes this code should
		    be interpreted as a i8086 (16-bit) binary intended to run
		    in a i386 (32-bit) machine (see note 3).

		    Alternative:

		    Issuing the build rule with the command-line variable
		    ALT=1 selects an alternative recipe using a single GCC 
		    invocation (GCC then invokes assembler and linker with
		    appropriate arguments).


* eg-07-beta.c	    Like eg-06.S, but translated into C.

   		    We use basic inline assembly.

		    Note that the string is now allocated in the read-only
		    section of the object code --- and also the ad hoc
		    workaround (aka dirty hack) we used (see comments in
		    the source file).

		    Alternatives:

		    b) Issuing the build rule with the command-line variable
		    ALT=1 selects an alternative recipe using a linker
		    script which stands in for some of the compiler's and
		    linker's flags, in particular, the instructions to
		    generate flat binary, set entry point and copy only
		    the code (.text) section to the output.

		    a) Issuing the build rule with the command-line variable
		    ALT=1 selects an alternative recipe using a single line
		    compiler (gcc) invocation.


 * eg-07.c	    Like eg-07-beta.c, but handling .rodata with the ld script

   		    It is now opportune to verify what has being said in the
		    comments of eg-05.S, about GCC not being found of 16-bit
		    assembler. See note 5.


# Here

 * eg-08.c	    Like eg-08.S


 Troubleshooting
 ------------------------------

 You are encouraged to send boot reports and fixes to the software author.

 Some known issues and tentative workarounds are here listed.

 - Issue: my image boots ok with the emulator but not with the hardware.

   If you have prepared your stick with


      make stick IMG=foo.bin STICK=/dev/sdX

   try then, instead

      make stick IMG=foo.iso STICK=/dev/sdX

 - Issue: I used the regular cp command to transfer image.bin to my stick.

   No, it does not work. Utility cp relies on the OS to transfer data
   to a formatted media. It will choose where to store the data
   and it will certainly not be to the MBR area. You can either
   use cat, dd or, if your BIOS needs, xorriso.


 Notes
 ------------------------------

 (1)   Original PC's BIOS used to read the MBR from the first 512 bytes of
       either the floppy or hard disks. Later on, when CD-ROM technology
       came about, it brought a different specification for the boot
       information, described in the iso9960 (the conventional CD file system
       format). Vendors then updated the BIOSes to detect whether the storage
       is either a floppy (or HD) or a CD-ROM, and apply the appropriate boot
       procedure. More recently, when USB flash devices were introduced, the
       approach adopted by BIOS vendors was not to specify a new boot procedure,
       but to emulate  some of the former devices. The problem is that this
       choice is not very consistent: some BIOSes would detect a USB stick as
       a floppy, whereas other BIOSes would see it as a CD (welcome to the
       system layer!).

       If your BIOS mimics the original PC, to make a bootable USB stick
       all you need to do is to copy the MBR code to its first 512 bytes:


   	  make stick IMG=foo.bin STICK=/dev/sdX


       On the other hand, if your BIOS insists in detecting your USB stick
       as a CD-ROM, you'll need to prepare a bootable iso9660 image as
       described in El-Torito specification [2]. 

       As for that, the GNU xorriso utility may come in handy: it prepares a
       bootable USP stick which should work in both scenarios. Xorriso copies
       the MBR code to the first 512 bytes to the USB stick and, in addition,
       it also transfer a prepared iso9660 to the right location. If you can't
       get your BIOS to boot and execute the example with the above (floppy)
       method, then try

         make stick IMG=foo.iso STICK=/dev/sdX


       We wont cover iso9660 El-Torito boot for CD-ROM, as newer x86-based
       computers now offers the Unified Extensible Firmware Interface meant
       to replace the BIOS interface of the original PC.  EFI is capable
       of decoding a format device, allowing the MBR code to be read from a
       standard file system. Although EFI is gradually turning original PC
       boot obsolete, however, most present day BIOSes offer a so called
       "legacy mode BIOS" and its useful to understand more sophisticated
       technologies, as low-level boot is still often found in legacy
       hardware and embedded systems.



 (2)  One reason we had better switch from nasm (Intel) to gas (AT&T)
      assembly here is because GCC (compiler) and NASM (assembler) do
      not go that well together. Actually, although GCC outputs AT&T syntax
      by default, it is true that GCC is capable of outputing Intel
      assembly if asked by means of the 'masm' option.  The problem is that
      the latter comes in specific Intel assembly dialect meant for GAS
      (GNU Assembler), which is not the same as that understood by NASM
      --- for instance, some directives (such as 'bit 16' vs .code16,
      times vs .fill etc.), data types ('dw' vs 'word'), and mnemonics
      (mov vs moveb, movel etc.) differ.

      A glimpse of those differences may be seen in egx-03.S.

      It's therefore not practical to ask GCC to generate intel assembly
      from C, and have the latter assembled by nasm; we would need to
      use GAS, instead anyway.

      As a side note, that is why we do not refer to assembly as a
      "programming language", in the same way we refer to the C language
      but, as the name implies, as an "assembling language". Diverse
      assembly standards vary in syntax and thereby constitute different 
      specifications. Moreover, the assembly code is dependent on the
      processor architecture e.g. i386 vs ARM etc.

      If we want to read the assembly generated by GCC, even if we ask
      for Intel syntax, we would need to learn a new dialect --- whose
      differences are not only a matter of syntax, but also of semantics.
      For instance, the way NASM compiler works with directive 'org'
      is very different from how GAS works in association to the linker
      (ld) to relocate code.  It so happens that it may be arguably more
      interesting learn the native GCC toolchain assembly dialect and
      proceed therefrom.


 (3)  The ISO C standard specifies the support for the insertion of
      assembly code within the body of a C source code, by means
      of a feature referred to as inline assembly.

      GCC supports inline assembly through the declaration

      __asm__ ("string");

      where "string" is a piece of assembly code. GCC does not
      interpret the contents of the string and output it as is
      in the produced assembly.

      See egx-01.c for an example.

      The code illustrates the user of the qualified 'register' to
      force a variable to allocated in a register rather than in
      work memory (RAM) as it's normally done.  This allows us
      to store a value in the register using the regular variable
      attribution syntax.

      Build it and disassembly with

         make diss IMG=eg-03.bin


 (3) Put short, GCC toolchain is not currently proficient in producing
      proper object code from C inline assembly source code intended
      to manipulate 8-bit registers directly, that is

      register char ax __asm__("ax");

      does not work as expected.

      In order to dig into this issue, it's first useful to understand
      how 8, 16 and 32-bit registers are handled by the x86 architecture.

      Consider either example egx-02-32bit.S, in GAS dialect or, alternatively,
      exg-04-32bit.asm, an equivalent in NASM dialect. The result of the
      experiment should be the same.

      The program instructs the assembler to generate code for a 32-bit
      (x86) CPU. The object code is supposed to store arbitrary values
      in ah, ax and eax.

      Build it and inspect the output with

         make diss IMG=egx-02-32bit-nasm.bin

         or

         make diss IMG=egx-02-32bit-gas.bin


      The output should identical:

         0:	b4 01                	mov    $0x1,%ah
   	 2:	66 b8 02 00          	mov    $0x2,%ax
   	 6:	b8 03 00 00 00       	mov    $0x3,%eax

      Line 0 uses opcode 0xb4 to store 1 in ah; the same we've got when
      we compiled eg-04.asm or eg-05.S. This instruction takes 1 byte
      as argument.

      Line 6 uses the opcode 0xb8 to store 3 in eax. This instruction takes
      4 bytes as argument.

      Now look at line 6. It is supposed to store 2 in ax and needs 2 bytes
      as argument. This would sum up 3 bytes, but the line is 4-bytes long.
      Staring at the last byte in the line and moving backwards, we can
      clearly identify the instruction 0xb8, the same as in line 6, and
      the 2-byte representation of 0x2 in little endian.

      But as we've seen, 0xb8 takes 4-bytes and store in eax. What is
      happening here? Well, look at the first byte at line 2, the one
      preceding the 0xb8 instruction. It is a instruction prefix.
      More specifically, 0x66 is a "Operand size overwrite" prefix.
      Its effect is to toggle the normal (non-prefixed) length of the
      next instruction's argument. In this case, from 32-bit to 16-bit.

      This is how the 32-bit x86 architecture stores a value in a 16-bit
      register in our example. While for ah and eax the assembler uses
      different opcodes for the respective operations, for ax it uses
      the same instruction that is used for eax, but with a operand
      size overwrite prefix.

      Now let's do the same thing with egx-02-16bit.asm.

         make diss IMG=egx-02-32bit-nasm.bin 16

         or

         make diss IMG=egx-02-32bit-gas.bin 16

      The only different from the previous 32bit versions is the directive
      to select 16 bits, but the disassembly shows
      

         0:	b4 01                	mov    $0x1,%ah
   	 2:	b8 02 00             	mov    $0x2,%ax
   	 5:	66 b8 03 00 00 00    	mov    $0x3,%eax

      Compare to the previous result:

         0:	b4 01                	mov    $0x1,%ah
   	 2:	66 b8 02 00          	mov    $0x2,%ax
   	 6:	b8 03 00 00 00       	mov    $0x3,%eax

      Line 0 has not changed.

      Line 2, however, has. It lost the operand size overwrite prefix, which
      passed to the line 6.

      This time, we told the assembler we were targeting a 16-bit (8080)
      CPU. Instruction 0xb4 works as usual. But now the normal (non-prefixed)
      default argument length of 0xb8 is 2-bytes (16 bits). It's the manipulation
      of eax (32 bits) that need the operand size overwrite prefix.

      Why x86 code reuses the same instruction to move to ax and eax, by means
      of prefixes, rather than having a specific instruction for each? This is
      a design decision. But it's not hard to notice that eax and ax are,
      after all, portions of the same 64-bit register found in x86_64. It may
      make sense from the hardware design perspective.
      
      Well, so far so good.

      But what is the problem with manipulating 8-bit registers with inline
      assembly anyway?

      Now GCC's own quirks come into play.

      Consider the example egx-07.c.

      We use inline assembly to force the variables to be allocated into
      registers (see note 3a).

      Now build and inspect with

         make egx-07-16bit.bin/diss 16

         0:	66 bb 01 00 00 00    	mov    $0x1,%ebx
   	 6:	66 b8 02 00 00 00    	mov    $0x2,%eax
   	 c:	66 b8 03 00 00 00    	mov    $0x3,%eax
  	 12:	66 b8 04 00 00 00    	mov    $0x4,%eax
  	 18:	90                   	nop
  	 19:	0f 0b                	ud2    

	 
      Line 0 uses 0x66 prefix to store the next 4 bytes in bx, discarding
      the remaining two. Line 6 does the same with for ax.

      Now see line c. It should store 1 byte in ah. However it's just another
      0xb8 move instruction prefixed to store the next two bytes in eax.
      The same as 'mov $0x3, ax'. Line 12, likewise, will store in eax,
      overriding anything we had put in ah in the previous step.

      If we had written the assembly manually as in egx-02, we would have used
      'mov $0x3, %ah' and this would have resulted in a 0xb4 instruction as before.

      But this is not what GCC itself does. Just build both the 16 and 32-bit
      versions of the same example

      	 make egx-07-32bit.bin

      	 make egx-07-16bit.bin

      And see the generated assembly files

        cat egx-07-32.bit.s
        cat egx-07-16.bit.s
	
      or

        diff egx-07-32.bit.s egx-07-16.bit.s
     

      and observe that the only different is the directive .cod116gcc.

      As we can notice, GCC always use the 32-bit registers and rely on GAS
      to honor the 16-bit directive.

      We can see the result by comparing

      	 make egx-07-16bit.bin/diss 16
      	 make egx-07-32bit.bin/diss 32


      The conclusion is that the code is not honoring what the C source says.
      This is a known issue and not exactly a bug, seen that GCC does not
      even claim the support to operate with 8-bit register variables. We
      are pushing it too hard.  There are other C compilers out there
      which do support this kind of operation, but if we are to explore
      GCC, we should avoid manipulating 8-bit register variables.
      


     


 References
 ------------------------------
 
 [1] Auxiliary program: syseg/src/hex2bin

 [2] El-Torito: https://wiki.osdev.org/El-Torito